4.20*: Blog List Expansion, step 8
This example from part 4 shows taking the token from the header with the getTokenFrom helper function in controllers/blogs.js.

If you used the same solution, refactor taking the token to a middleware. The middleware should take the token from the Authorization header and assign it to the token field of the request object.

In other words, if you register this middleware in the app.js file before all routes

app.use(middleware.tokenExtractor)copy
Routes can access the token with request.token:

blogsRouter.post('/', async (request, response) => {
  // ..
  const decodedToken = jwt.verify(request.token, process.env.SECRET)
  // ..
})copy
Remember that a normal middleware function is a function with three parameters, that at the end calls the last parameter next to move the control to the next middleware:

const tokenExtractor = (request, response, next) => {
  // code that extracts the token

  next()
}copy
4.21*: Blog List Expansion, step 9
Change the delete blog operation so that a blog can be deleted only by the user who added it. Therefore, deleting a blog is possible only if the token sent with the request is the same as that of the blog's creator.

If deleting a blog is attempted without a token or by an invalid user, the operation should return a suitable status code.

Note that if you fetch a blog from the database,

const blog = await Blog.findById(...)copy
the field blog.user does not contain a string, but an object. So if you want to compare the ID of the object fetched from the database and a string ID, a normal comparison operation does not work. The ID fetched from the database must be parsed into a string first.

if ( blog.user.toString() === userid.toString() ) ...copy
4.22*: Blog List Expansion, step 10
Both the new blog creation and blog deletion need to find out the identity of the user who is doing the operation. The middleware tokenExtractor that we did in exercise 4.20 helps but still both the handlers of post and delete operations need to find out who the user holding a specific token is.

Now create a new middleware called userExtractor that identifies the user related to the request and attaches it to the request object. After registering the middleware, the post and delete handlers should be able to access the user directly by referencing request.user:

blogsRouter.post('/', userExtractor, async (request, response) => {
  // get user from request object
  const user = request.user
  // ..
})

blogsRouter.delete('/:id', userExtractor, async (request, response) => {
  // get user from request object
  const user = request.user
  // ..
})copy
Note that in this case, the userExtractor middleware has been registered with individual routes, so it is only executed in certain cases. So instead of using userExtractor with all the routes,

// use the middleware in all routes
app.use(middleware.userExtractor)

app.use('/api/blogs', blogsRouter)  
app.use('/api/users', usersRouter)
app.use('/api/login', loginRouter)copy
we could register it to be only executed with path /api/blogs routes:

// use the middleware only in /api/blogs routes
app.use('/api/blogs', middleware.userExtractor, blogsRouter)
app.use('/api/users', usersRouter)
app.use('/api/login', loginRouter)copy
This is done by chaining multiple middleware functions as parameters to the use function. In the same way, middleware can also be registered only for individual routes:

router.post('/', userExtractor, async (request, response) => {
  // ...
})copy
Make sure that fetching all blogs with a GET request still works without a token.

4.23*: Blog List Expansion, step 11
After adding token-based authentication the tests for adding a new blog broke down. Fix them. Also, write a new test to ensure adding a blog fails with the proper status code 401 Unauthorized if a token is not provided.

This is most likely useful when doing the fix.